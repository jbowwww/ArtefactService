30/12/13 -
	See Output/*.txt for successful test outputs
	About to attempt improving Artefacts.Drive class to include a disk serial number as reported by shell command:
		/sbin/udevadm info --query=property --name=sda
			- What does it report for non-HD partitions??
---------------------------------

02/12/13 - 
	Think I now have :
		A basic WCF service running, currently with one operation, AddArtefact, which persists the passed artefact
		using NHibernate. This service is run with a ServiceHost instance, constructed in and opened from another
		thread. Once the ServiceHost is opened, the thread simply loops, calling Thread.Sleep(200ish) until the
		boolean flag is set to exit. When the thread has been flagged and is exiting, it closes the ServiceHost
		instance before exiting.
			- ALl inside a lambda function inside a new Thread instance in ClientTest.cs. Move somewhere more appropriate & tidy up
		
		A basic WCF client proxy, constructed and controlled from the main thread. When AddArtefact is called
		on the proxy, the service implementation should be invoked.
		
		The exact state I just backed up in ArtefactService-131202-0430.tar.gz, still does not succeed when the proxy's method is called -
		For the majority of today up until just now the call to the proxy cause an exception to be thrown on the client 
		that said the server had an internal service error, and nothing else
			- Figured there was probably an unhandled exception being thrown on the server
			- The ServiceHost thread code was already wrapped in a try catch finally block, and I don't think it's caught any, and probably won't
			- Where the exception needs to be, and is now being, caught, in this case is in the server's implementaiton of AddArtefact
			  (and likewise for any other service operations / methods that are implemented by the service)
				- The method gets invoked by the channel, so there is user code that will be higher in the stack frame
				  And so the code of AddArtefact and any other service methods you implement, must be wrapped
				  in a try catch finally block
				  
 TODO: 
  See if you acttuallly need the thread running the server -
  Now that you realised the server's exceptions had to be caught within each service operation method (which gets invoked
  using refelection by the system) and have done that, it might actually work fine if you go back to the single threaded approach
  you had previously. Whole application is surrounded by a using (ServiceHost sh = ....), inside this is a try block which calls
  sh.Open(), catch, finally calls sh.Close(). ServiceHost must run a whole separate Process containing threads that listen on the configured channels